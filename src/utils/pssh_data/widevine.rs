// MIT License
//
// Copyright (c) 2024-2025 Eric Marsden
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::utils::hex::encode_hex;

// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
#[prost(skip_debug)]
pub struct WidevinePsshData {
    #[prost(enumeration = "widevine_pssh_data::Algorithm", optional, tag = "1")]
    pub algorithm: ::core::option::Option<i32>,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub key_id: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Content provider name.
    #[prost(string, optional, tag = "3")]
    pub provider: ::core::option::Option<::prost::alloc::string::String>,
    /// A content identifier, specified by content provider.
    #[prost(bytes = "vec", optional, tag = "4")]
    pub content_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The name of a registered policy to be used for this asset.
    #[prost(string, optional, tag = "6")]
    pub policy: ::core::option::Option<::prost::alloc::string::String>,
    /// Crypto period index, for media using key rotation.
    #[prost(uint32, optional, tag = "7")]
    pub crypto_period_index: ::core::option::Option<u32>,
    /// Optional protected context for group content. The grouped_license is a
    /// serialized SignedMessage.
    #[prost(bytes = "vec", optional, tag = "8")]
    pub grouped_license: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Protection scheme identifying the encryption algorithm. Represented as one
    /// of the following 4CC values: 'cenc' (AES-CTR), 'cbc1' (AES-CBC),
    /// 'cens' (AES-CTR subsample), 'cbcs' (AES-CBC subsample).
    #[prost(
        enumeration = "widevine_pssh_data::ProtectionScheme",
        optional,
        tag = "9"
    )]
    pub protection_scheme: ::core::option::Option<i32>,
}
/// Nested message and enum types in `WidevinePsshData`.
pub mod widevine_pssh_data {
    #[derive(
        serde::Serialize,
        serde::Deserialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum ProtectionScheme {
        /// Defaults to 'cenc'
        Unspecified = 0,
        /// 'cenc' (AES-CTR) = 0x63656E63
        Cenc = 1667591779,
        /// 'cbc1' (AES-CBC) = 0x63626331
        Cbc1 = 1667392305,
        /// 'cens' (AES-CTR subsample) =
        Cens = 1667591795,
        /// 0x63656E73
        ///
        /// 'cbcs' (AES-CBC subsample) = 0x63626373
        Cbcs = 1667392371,
    }
    impl ProtectionScheme {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Cenc => "CENC",
                Self::Cbc1 => "CBC1",
                Self::Cens => "CENS",
                Self::Cbcs => "CBCS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "CENC" => Some(Self::Cenc),
                "CBC1" => Some(Self::Cbc1),
                "CENS" => Some(Self::Cens),
                "CBCS" => Some(Self::Cbcs),
                _ => None,
            }
        }
    }
    #[derive(
        serde::Serialize,
        serde::Deserialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum Algorithm {
        Unencrypted = 0,
        Aesctr = 1,
    }
    impl Algorithm {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unencrypted => "UNENCRYPTED",
                Self::Aesctr => "AESCTR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNENCRYPTED" => Some(Self::Unencrypted),
                "AESCTR" => Some(Self::Aesctr),
                _ => None,
            }
        }
    }
}
/// Derived from WidevinePsshData. The JSON format of this proto is used in
/// Widevine HLS DRM signaling v1.
/// We cannot build JSON from WidevinePsshData as |key_id| is required to be in
/// hex format, while |bytes| type is translated to base64 by JSON formatter, so
/// we have to use |string| type and do hex conversion in the code.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct WidevineHeader {
    #[prost(string, repeated, tag = "2")]
    pub key_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Content provider name.
    #[prost(string, optional, tag = "3")]
    pub provider: ::core::option::Option<::prost::alloc::string::String>,
    /// A content identifier, specified by content provider.
    #[prost(bytes = "vec", optional, tag = "4")]
    pub content_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}

impl std::fmt::Debug for WidevinePsshData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut items = Vec::new();
        if let Some(a) = &self.algorithm {
            items.push(if *a == 0 {
                String::from("unencrypted")
            } else {
                String::from("Aesctr")
            });
        }
        if let Some(p) = &self.provider {
            items.push(format!("provider: {p}"));
        }
        if let Some(p) = &self.policy
            && !p.is_empty()
        {
            items.push(format!("policy: {p}"));
        }
        if let Some(cpi) = &self.crypto_period_index {
            items.push(format!("crypto_period_index: {cpi}"));
        }
        if let Some(gl) = &self.grouped_license {
            items.push(format!("grouped_licence: {}", encode_hex(gl)));
        }
        // In the 2016 version of the protobuf for WidevinePsshData, the protection_scheme field is
        // specified as a uint32. In 2018 versions there is a ProtectionScheme enum which specifies
        // values for the uint32.
        if let Some(ps) = &self.protection_scheme {
            let scheme = match widevine_pssh_data::ProtectionScheme::try_from(*ps) {
                Ok(s) => String::from(s.as_str_name()),
                Err(_) => format!("unknown ({ps})"),
            };
            items.push(format!("protection_scheme: {scheme}"));
        }
        for kid in &self.key_id {
            items.push(format!("keyid: {}", encode_hex(kid)));
        }
        if let Some(cid) = &self.content_id {
            items.push(format!("content_id: {}", encode_hex(cid)));
        }
        write!(f, "WidevinePsshData<{}>", items.join(", "))
    }
}
